#include<iostream>
#include<thread>
#include<condition_variable>
#include<mutex>
#include <queue>
#include <chrono>
#include<string>
#include <fstream>
#include <atomic>
#include <sstream>


template<typename T>
class Bounded_Queue
{
    public:
    
    std::queue<T>q;
    std::mutex mt;
    std::condition_variable not_empty;
    std::condition_variable not_full;
    int m_size;
    
    
    Bounded_Queue(int size):m_size(size)
    {
        
    }
    
    Bounded_Queue(const Bounded_Queue&) = delete;
    Bounded_Queue& operator=(const Bounded_Queue&) = delete;
    
    void enqueue(const T& data)
    {
            std::unique_lock<std::mutex>lk(mt);
            not_full.wait(lk,[&]()
            {
                return q.size()<m_size;
            });
            
            q.push(data);
            not_empty.notify_one();
    }
    
    T dequeue()
    {
        std::unique_lock<std::mutex>lk(mt);
        not_empty.wait(lk,[&]()
        {
            return !q.empty();
        }
        );
        
        T data = q.front();
        q.pop();
        not_full.notify_one();
        return data;
        
    }
    
    bool empty()
    {
        std::lock_guard<std::mutex>lk(mt);
        return q.empty();
    }
    ~Bounded_Queue()
    {
        
    }
    
};


class SerialProducer
{
public:

        SerialProducer(Bounded_Queue<std::string>&q,std::atomic<bool>&r):
        bq(q),running(r)
        {
            
        }
        
        SerialProducer(const SerialProducer&) = delete;
        SerialProducer& operator=(const SerialProducer&) = delete;

        
        void runProducer()
        {
            while(running)
            {
                std::string data = "Serial Data" + std::to_string(++count);
                
                std::cout<<"Producer Reade Data ="<<data<<std::endl;
                
                bq.enqueue(data);
                
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
            }
            
        }

        
        ~SerialProducer()
        {
            std::cout<<"~SerialProducer"<<std::endl;
        }
        
private:
        Bounded_Queue<std::string> &bq;
        std::atomic<bool>&running;
        int count = 0;
        

};


class LogConsumer
{
  
  
  public:
  LogConsumer(Bounded_Queue<std::string>&q,std::atomic<bool>&r):
  bq(q),running(r)
  {
      
  }
  
  LogConsumer(const LogConsumer&) = delete;
  LogConsumer& operator=(const LogConsumer&) = delete;


  void runConsumer()
  {
// std::string sFile="C:/Users/Bhavesh/Desktop/C++/Toy_Projects/Multithreading/log.txt";
        
        // std::cout << "Trying to open: " << sFile << std::endl;
        // std::ofstream ofs(sFile);
        // std::cout<<"Starting Log"<<std::endl;
        std::ostringstream oss;
        // if(!ofs.is_open())
        //   {
        //       std::cerr<<"Failed file opening";
        //       return;
        //   }
          
      while(running || !bq.empty())
      {
            std::string data = bq.dequeue();
            
            // ofs << "[LOG]" <<data<<"\n";
           oss <<  "[LOG]" <<data<<"\n";
           
            std::cout<<"Logged Data = "<<data<<std::endl;
          
          std::this_thread::sleep_for(std::chrono::milliseconds(500));

          oss.str();

      }
            //   ofs.close();
  }
  
  private:
  Bounded_Queue<std::string>&bq;
  std::atomic<bool>&running;
  
};


int main()
{
    std::atomic<bool>running(true);
    Bounded_Queue<std::string>bq(10);
    
    LogConsumer lgConsumer(bq,running);
    SerialProducer sProducer(bq,running);
    
    
    std::thread producerThread(&SerialProducer::runProducer,&sProducer);
    std::thread consumerThread(&LogConsumer::runConsumer,&lgConsumer);
    
    std::this_thread::sleep_for(std::chrono::seconds(10));
    running = false;
    
    std::cout<<"Log Finished"<<std::endl;
    
    
    
    producerThread.join();
    consumerThread.join();
}
